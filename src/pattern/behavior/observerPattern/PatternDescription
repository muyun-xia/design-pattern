

观察者模式(observer pattern):

    在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.

    1，目标与观察者之间的关系，目标与观察者是多对多的关系，也要可以简化好一对一的关系，一般下观察者观察者需要                       对不同的目标定义不同的回调方法，便于区分目标。
    2，单项依赖，只有观察者依赖目标，而不是目标依赖观察者，联系主动权掌握在目标手里。
    3，命名建议， 模式有被称为发布-订阅模式，
    	1，目标接口，建议目标接口后面添加Subject作为目标标示。
    	2，观察者接口，接口后面添加Observes作为目标标示。
    	3，观察者接口的更新方法，命名为update。
    4，触发通知的时机，一般情况下是在完成状态维护后触发。
    5，通知的顺序，通知时，通知的顺序是不确定的，所以多个观察者之间的通知顺序应该是平行的，不应该有依赖关系。

    观察者模式的实现方法，推模型，拉模型。
		推模型：目标对象主动向观察者推送目标的详细信息，推送的信息通常是目标的全部或部分数据。
		拉模型：目标对象在通知观察者是，只推送少量的信息，如果观察者需要具体的信息。由观察者主动到目标对象中获取。
		        一般这种模型实现中，会把目标对象自身通过update方法传递给观察者。

	JAVA 本身对观察者模式的实现 java.util.Observable类
	    1，不需要自己定义观察者和目标的接口了，JDK已经定义好了
	    2，具体的目标实现里不需要再维护观察者的注册信息了，这个已经在Java的Observable类里帮忙实现了
	    3，触发通知的方式有所不同，需要先调用setChanged()方法，这个是Java为了帮助实现更加精确的触发控制而
	       提供的功能
	    4，具体的观察者的实现里update方法能够同时支持推模型和拉模型，这个是java在定义的时候，已经考虑好了的


	观察者模式的优点：
	    1，实现了观察者和目标之间的抽象耦合
	    2，实现了观察者和目标的动态联动
	    3，支持广播通信

	观察者模式的缺点：
	    可能会引起无谓的操作

    观察者模式的本质：触发联动。当修改目标对象状态时，会触发通知，然后循环调用所有的观察者对象的相应的方法。

    建议在以下情形下使用观察者模式
        1，当一个抽象模型有两个方面，一个方面的操作，依赖于另一个方面的状态变化。
        2，如果在更改一个对象的时候，需要联动改变其他对象，而且不知道应该有多少对象需要被连带改变。
        3，当一个对象必须通知其他对象，但是你又希望这个对象和其他被通知的对象是松散耦合的。

